class Node(object):
    def __init__(self,val,left=None,right=None):
        self.val = val
        self.left = left
        self.right = right

class Bitree:
    def __init__(self, root=None):
        self.root = root
    
    
    def is_empty(self):
        if self.root is None:
            return True
        else:
            return False

    
    def preOrder(self, root):# 先序遍历
        ans = []
        stack = [root]
        while stack:
            node = stack.pop()
            ans.append(node.val)
            #print(node.val)
            if node.right:
                stack.append(node.right)
            if node.left:
                stack.append(node.left)  
        print(ans)
        return ans
            
            
    def inOrder(self, root):# 中序遍历    
        ans = []
        stack = []
        while stack or root:
            if root:
                stack.append(root)
                root = root.left
            else:
                root = stack.pop()
                ans.append(root.val)
                #print(root.val)
                root = root.right
        print(ans)
        return ans
           
           
    def posOrder(self, root):# 后序遍历     
        stack = [root]
        stack2 = [] 
        while stack:
            node = stack.pop()
            if node.left:
                stack.append(node.left)
            if node.right:
                stack.append(node.right)
            stack2.append(node)
          # 将stack2中的元素出栈，即为后序遍历次序
        ans = []
        for i in stack2[::-1]:
            ans.append(i.val)
            #print(i.val)
        print(ans)
        return ans


    def levelOrder(self, root):#层次遍历
        queue = [root]   
        ans=[]
        while queue:
            temp = []
            for i in range(len(queue)):
                node = queue.pop(0)
                #print(node.val)
                temp.append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            ans.append(temp)
        print(ans)
        return ans
        
        
def DFS(root):#类似先序遍历
    stack = [root]
    while stack:
        node = stack.pop()
        print(node.val,end=" ")
        if node.right:
            stack.append(node.right)
        if node.left:
            stack.append(node.left)   
            
            
def BFS(root):#类似层次遍历
    queue = [root]   
    while queue:
        node = queue.pop(0)
        if node.left:
            queue.append(node.left)
        if node.right:
            queue.append(node.right)
        print(node.val,end=" ")
  
          
class Solution(object):#构造二叉树
    def buildTree(self, preorder, inorder):
        if not preorder: 
            return None
        
        x = preorder.pop(0)
        node = TreeNode(x)
        i = inorder.index(x)
        
        node.left = self.buildTree(preorder[:i], inorder[:i])
        node.right = self.buildTree(preorder[i:], inorder[i+1:])
        return node  
        
        
    def buildTree(self, preorder, inorder) :
        if not preorder:
            return None
            
        root = TreeNode(preorder[0])
        stack = [root]
        inorderIndex = 0
        for i in range(1, len(preorder)):
            preorderVal = preorder[i]
            if  stack[-1].val != inorder[inorderIndex]:                
                stack[-1].left = TreeNode(preorderVal)
                stack.append(stack[-1].left)                
            else:
                while stack and stack[-1].val == inorder[inorderIndex]:
                    node = stack.pop()
                    inorderIndex += 1
                node.right = TreeNode(preorderVal)
                stack.append(node.right)
        return root
        
        

if __name__ == "__main__":
    treeroot = Node("A",Node("B",Node("D"),Node("E",Node('H'))),Node("C",Node("F"),Node("G")))
    bt = Bitree()
    print("" ,"pre:")
    bt.preOrder(treeroot) 
    
    print("" ,"in:")
    bt.inOrder(treeroot) 
    
    print("" ,"pos:")
    bt.posOrder(treeroot) 
    
    print('',"levelOrder:")
    bt.levelOrder(treeroot) 
    
    print("DFS:",end=" ")
    DFS(treeroot)
    print('')
    print("BFS:",end=" ")
    BFS(treeroot)
    print('')

    
    preorder = [3,9,8,5,4,6,10,20,15,7]
    inorder  = [4,5,6,8,10,9,3,15,20,7]
            
            
